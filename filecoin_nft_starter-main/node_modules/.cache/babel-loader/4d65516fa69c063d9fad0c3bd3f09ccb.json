{"ast":null,"code":"import { CarReader, CarWriter } from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [pb, raw, cbor, ...(options.decoders || [])];\n  }\n\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1) throw new Error(`unexpected number of roots: ${roots.length}`);\n    let channel;\n\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out) yield val.out;\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    channel.writer.close();\n    yield channel.out;\n  }\n\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock) throw new Error(`missing block for ${cid}`);\n    const {\n      bytes\n    } = rawBlock;\n\n    const decoder = this._decoders.find(d => d.code === cid.code);\n\n    if (!decoder) throw new Error(`missing decoder for ${cid.code}`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n\n  async *_cars(cid) {\n    let parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    const block = await this._get(cid);\n    channel = channel || Object.assign(CarWriter.create(cid), {\n      size: 0\n    });\n\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {\n        out\n      } = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    yield {\n      channel\n    };\n  }\n\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n}\n\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), {\n    size: parents.reduce((size, b) => size + b.bytes.byteLength, 0)\n  });\n\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n\n  return ch;\n}","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/carbites/esm/lib/treewalk/splitter.js"],"names":["CarReader","CarWriter","Block","raw","cbor","pb","TreewalkCarSplitter","constructor","reader","targetSize","options","Error","_reader","_targetSize","_decoders","decoders","cars","roots","getRoots","length","channel","val","_cars","out","writer","close","_get","cid","rawBlock","get","bytes","decoder","find","d","code","value","decode","parents","undefined","block","Object","assign","create","size","byteLength","newCar","concat","put","links","fromIterable","iterable","fromBlob","blob","buffer","arrayBuffer","fromBytes","Uint8Array","ch","reduce","b"],"mappings":"AAAA,SACEA,SADF,EAEEC,SAFF,QAGO,WAHP;AAIA,SAASC,KAAT,QAAsB,oBAAtB;AACA,OAAO,KAAKC,GAAZ,MAAqB,yBAArB;AACA,OAAO,KAAKC,IAAZ,MAAsB,gBAAtB;AACA,OAAO,KAAKC,EAAZ,MAAoB,cAApB;AACA,OAAO,MAAMC,mBAAN,CAA0B;AAC/BC,EAAAA,WAAW,CAACC,MAAD,EAASC,UAAT,EAAmC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC5C,QAAI,OAAOD,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,IAAI,CAApD,EAAuD;AACrD,YAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,SAAKC,OAAL,GAAeJ,MAAf;AACA,SAAKK,WAAL,GAAmBJ,UAAnB;AACA,SAAKK,SAAL,GAAiB,CACfT,EADe,EAEfF,GAFe,EAGfC,IAHe,EAIf,IAAGM,OAAO,CAACK,QAAR,IAAoB,EAAvB,CAJe,CAAjB;AAMD;;AACU,SAAJC,IAAI,GAAG;AACZ,UAAMC,KAAK,GAAG,MAAM,KAAKL,OAAL,CAAaM,QAAb,EAApB;AACA,QAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EACE,MAAM,IAAIR,KAAJ,CAAW,+BAA+BM,KAAK,CAACE,MAAQ,EAAxD,CAAN;AACF,QAAIC,OAAJ;;AACA,eAAW,MAAMC,GAAjB,IAAwB,KAAKC,KAAL,CAAWL,KAAK,CAAC,CAAD,CAAhB,CAAxB,EAA8C;AAC5CG,MAAAA,OAAO,GAAGC,GAAG,CAACD,OAAd;AACA,UAAIC,GAAG,CAACE,GAAR,EACE,MAAMF,GAAG,CAACE,GAAV;AACH;;AACD,QAAI,CAACH,OAAL,EAAc;AACZ,YAAM,IAAIT,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACDS,IAAAA,OAAO,CAACI,MAAR,CAAeC,KAAf;AACA,UAAML,OAAO,CAACG,GAAd;AACD;;AACS,QAAJG,IAAI,CAACC,GAAD,EAAM;AACd,UAAMC,QAAQ,GAAG,MAAM,KAAKhB,OAAL,CAAaiB,GAAb,CAAiBF,GAAjB,CAAvB;AACA,QAAI,CAACC,QAAL,EACE,MAAM,IAAIjB,KAAJ,CAAW,qBAAqBgB,GAAK,EAArC,CAAN;AACF,UAAM;AAACG,MAAAA;AAAD,QAAUF,QAAhB;;AACA,UAAMG,OAAO,GAAG,KAAKjB,SAAL,CAAekB,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAWP,GAAG,CAACO,IAAxC,CAAhB;;AACA,QAAI,CAACH,OAAL,EACE,MAAM,IAAIpB,KAAJ,CAAW,uBAAuBgB,GAAG,CAACO,IAAM,EAA5C,CAAN;AACF,WAAO,IAAIhC,KAAJ,CAAU;AACfyB,MAAAA,GADe;AAEfG,MAAAA,KAFe;AAGfK,MAAAA,KAAK,EAAEJ,OAAO,CAACK,MAAR,CAAeN,KAAf;AAHQ,KAAV,CAAP;AAKD;;AACW,SAALR,KAAK,CAACK,GAAD,EAAyC;AAAA,QAAnCU,OAAmC,uEAAzB,EAAyB;AAAA,QAArBjB,OAAqB,uEAAXkB,SAAW;AACnD,UAAMC,KAAK,GAAG,MAAM,KAAKb,IAAL,CAAUC,GAAV,CAApB;AACAP,IAAAA,OAAO,GAAGA,OAAO,IAAIoB,MAAM,CAACC,MAAP,CAAcxC,SAAS,CAACyC,MAAV,CAAiBf,GAAjB,CAAd,EAAqC;AAAEgB,MAAAA,IAAI,EAAE;AAAR,KAArC,CAArB;;AACA,QAAIvB,OAAO,CAACuB,IAAR,GAAe,CAAf,IAAoBvB,OAAO,CAACuB,IAAR,GAAeJ,KAAK,CAACT,KAAN,CAAYc,UAA3B,IAAyC,KAAK/B,WAAtE,EAAmF;AACjFO,MAAAA,OAAO,CAACI,MAAR,CAAeC,KAAf;AACA,YAAM;AAACF,QAAAA;AAAD,UAAQH,OAAd;AACAA,MAAAA,OAAO,GAAGyB,MAAM,CAACR,OAAD,CAAhB;AACA,YAAM;AACJjB,QAAAA,OADI;AAEJG,QAAAA;AAFI,OAAN;AAID;;AACDc,IAAAA,OAAO,GAAGA,OAAO,CAACS,MAAR,CAAeP,KAAf,CAAV;AACAnB,IAAAA,OAAO,CAACuB,IAAR,IAAgBJ,KAAK,CAACT,KAAN,CAAYc,UAA5B;AACAxB,IAAAA,OAAO,CAACI,MAAR,CAAeuB,GAAf,CAAmBR,KAAnB;;AACA,SAAK,MAAM,GAAGZ,GAAH,CAAX,IAAsBY,KAAK,CAACS,KAAN,EAAtB,EAAqC;AACnC,iBAAW,MAAM3B,GAAjB,IAAwB,KAAKC,KAAL,CAAWK,GAAX,EAAgBU,OAAhB,EAAyBjB,OAAzB,CAAxB,EAA2D;AACzDA,QAAAA,OAAO,GAAGC,GAAG,CAACD,OAAd;AACA,cAAMC,GAAN;AACD;AACF;;AACD,QAAI,CAACD,OAAL,EAAc;AACZ,YAAM,IAAIT,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,UAAM;AAAES,MAAAA;AAAF,KAAN;AACD;;AACwB,eAAZ6B,YAAY,CAACC,QAAD,EAAWzC,UAAX,EAAuBC,OAAvB,EAAgC;AACvD,UAAMF,MAAM,GAAG,MAAMR,SAAS,CAACiD,YAAV,CAAuBC,QAAvB,CAArB;AACA,WAAO,IAAI5C,mBAAJ,CAAwBE,MAAxB,EAAgCC,UAAhC,EAA4CC,OAA5C,CAAP;AACD;;AACoB,eAARyC,QAAQ,CAACC,IAAD,EAAO3C,UAAP,EAAmBC,OAAnB,EAA4B;AAC/C,UAAM2C,MAAM,GAAG,MAAMD,IAAI,CAACE,WAAL,EAArB;AACA,UAAM9C,MAAM,GAAG,MAAMR,SAAS,CAACuD,SAAV,CAAoB,IAAIC,UAAJ,CAAeH,MAAf,CAApB,CAArB;AACA,WAAO,IAAI/C,mBAAJ,CAAwBE,MAAxB,EAAgCC,UAAhC,EAA4CC,OAA5C,CAAP;AACD;;AA9E8B;;AAgFjC,SAASmC,MAAT,CAAgBR,OAAhB,EAAyB;AACvB,QAAMoB,EAAE,GAAGjB,MAAM,CAACC,MAAP,CAAcxC,SAAS,CAACyC,MAAV,CAAiBL,OAAO,CAAC,CAAD,CAAP,CAAWV,GAA5B,CAAd,EAAgD;AAAEgB,IAAAA,IAAI,EAAEN,OAAO,CAACqB,MAAR,CAAe,CAACf,IAAD,EAAOgB,CAAP,KAAahB,IAAI,GAAGgB,CAAC,CAAC7B,KAAF,CAAQc,UAA3C,EAAuD,CAAvD;AAAR,GAAhD,CAAX;;AACA,OAAK,MAAMe,CAAX,IAAgBtB,OAAhB,EAAyB;AACvBoB,IAAAA,EAAE,CAACjC,MAAH,CAAUuB,GAAV,CAAcY,CAAd;AACD;;AACD,SAAOF,EAAP;AACD","sourcesContent":["import {\n  CarReader,\n  CarWriter\n} from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [\n      pb,\n      raw,\n      cbor,\n      ...options.decoders || []\n    ];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1)\n      throw new Error(`unexpected number of roots: ${ roots.length }`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out)\n        yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock)\n      throw new Error(`missing block for ${ cid }`);\n    const {bytes} = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder)\n      throw new Error(`missing decoder for ${ cid.code }`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(CarWriter.create(cid), { size: 0 });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {out} = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield { channel };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}"]},"metadata":{},"sourceType":"module"}