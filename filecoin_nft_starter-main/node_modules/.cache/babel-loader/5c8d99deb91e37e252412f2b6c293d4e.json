{"ast":null,"code":"\"use strict\"; // Runtime header offsets\n\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4; // Runtime ids\n\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2; // Runtime type information\n\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22; // Array(BufferView) layout\n\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n/** Gets a string from an U32 and an U16 view on a memory. */\n\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n/** Prepares the base module prior to instantiation. */\n\n\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  } // add common imports used by stdlib for convenience\n\n\n  const env = imports.env = imports.env || {};\n\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  };\n\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  };\n\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n  return baseModule;\n}\n/** Prepares the final module once instantiation is complete. */\n\n\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n  /** Gets the runtime base id for the given id. */\n\n\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n  /** Gets the runtime alignment of a collection's values. */\n\n\n  function getValueAlign(info) {\n    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31); // -1 if none\n  }\n  /** Gets the runtime alignment of a collection's keys. */\n\n\n  function getKeyAlign(info) {\n    return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31); // -1 if none\n  }\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n\n\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n  /** Reads a string from the module's memory by its pointer. */\n\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n\n    if (float) {\n      switch (alignLog2) {\n        case 2:\n          return new Float32Array(buffer);\n\n        case 3:\n          return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0:\n          return new (signed ? Int8Array : Uint8Array)(buffer);\n\n        case 1:\n          return new (signed ? Int16Array : Uint16Array)(buffer);\n\n        case 2:\n          return new (signed ? Int32Array : Uint32Array)(buffer);\n\n        case 3:\n          return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n\n\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n\n    const len = input.length;\n    const out = new Array(len);\n\n    for (let i = 0; i < len; i++) out[i] = input[i];\n\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n  /** Copies an ArrayBuffer's value from the module's memory. */\n\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n  /** Copies a typed array's values from the module's memory. */\n\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n  /** Gets a live view on a typed array's values in the module's memory. */\n\n\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[ptr + ID_OFFSET >>> 2];\n\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true; while (id = getBase(id));\n    }\n\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof; // Pull basic exports to baseModule so code in preInstantiate can use them\n\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table; // Demangle exports and provide the usual utility on the prototype\n\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\n\n\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));\n}\n\nexports.instantiate = instantiate;\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\n\nfunction instantiateSync(source, imports) {\n  return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));\n}\n\nexports.instantiateSync = instantiateSync;\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\n\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);\n  }\n\n  return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\n\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"] ? function (length) {\n    exports[\"__argumentsLength\"].value = length;\n  } : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function () {};\n\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n\n        ctor.wrap = function (thisValue) {\n          return Object.create(ctor.prototype, {\n            [THIS]: {\n              value: thisValue,\n              writable: false\n            }\n          });\n        };\n\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name => Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name)));\n        curr[className] = ctor;\n      }\n\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function () {\n              return getter(this[THIS]);\n            },\n            set: function (value) {\n              setter(this[THIS], value);\n            },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = function () {\n            setArgumentsLength(arguments.length);\n            return elem(...arguments);\n          }).original = elem;\n        } else {\n          // instance method\n          (curr[name] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = function () {\n          setArgumentsLength(arguments.length);\n          return elem(...arguments);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/@assemblyscript/loader/index.js"],"names":["ID_OFFSET","SIZE_OFFSET","ARRAYBUFFER_ID","STRING_ID","ARRAYBUFFERVIEW_ID","ARRAYBUFFERVIEW","ARRAY","SET","MAP","VAL_ALIGN_OFFSET","VAL_ALIGN","VAL_SIGNED","VAL_FLOAT","VAL_NULLABLE","VAL_MANAGED","KEY_ALIGN_OFFSET","KEY_ALIGN","KEY_SIGNED","KEY_FLOAT","KEY_NULLABLE","KEY_MANAGED","ARRAYBUFFERVIEW_BUFFER_OFFSET","ARRAYBUFFERVIEW_DATASTART_OFFSET","ARRAYBUFFERVIEW_DATALENGTH_OFFSET","ARRAYBUFFERVIEW_SIZE","ARRAY_LENGTH_OFFSET","ARRAY_SIZE","BIGINT","BigUint64Array","THIS","Symbol","CHUNKSIZE","getStringImpl","buffer","ptr","U32","Uint32Array","U16","Uint16Array","length","offset","String","fromCharCode","apply","subarray","parts","last","size","push","join","preInstantiate","imports","baseModule","getString","memory","env","abort","mesg","file","line","colm","Error","trace","n","console","log","Array","prototype","slice","call","arguments","Math","Date","postInstantiate","instance","rawExports","exports","table","alloc","retain","rttiBase","getInfo","id","count","getBase","getValueAlign","info","clz32","getKeyAlign","__allocString","str","i","p","charCodeAt","__getString","getView","alignLog2","signed","float","Float32Array","Float64Array","Int8Array","Uint8Array","Int16Array","Int32Array","BigInt64Array","__allocArray","values","align","buf","arr","view","set","__getArrayView","__getArray","input","len","out","__getArrayBuffer","getTypedArray","Type","getTypedArrayView","bufPtr","__getInt8Array","bind","__getInt8ArrayView","__getUint8Array","__getUint8ArrayView","__getUint8ClampedArray","Uint8ClampedArray","__getUint8ClampedArrayView","__getInt16Array","__getInt16ArrayView","__getUint16Array","__getUint16ArrayView","__getInt32Array","__getInt32ArrayView","__getUint32Array","__getUint32ArrayView","__getInt64Array","__getInt64ArrayView","__getUint64Array","__getUint64ArrayView","__getFloat32Array","__getFloat32ArrayView","__getFloat64Array","__getFloat64ArrayView","__instanceof","baseId","demangle","isResponse","o","Response","instantiate","source","instantiateStreaming","WebAssembly","Module","compile","instantiateSync","Instance","arrayBuffer","module","Object","create","setArgumentsLength","value","internalName","hasOwnProperty","elem","split","curr","part","shift","name","hash","indexOf","className","substring","classElem","ctor","args","wrap","constructor","valueOf","thisValue","writable","getOwnPropertyNames","forEach","defineProperty","getOwnPropertyDescriptor","test","getter","replace","setter","get","enumerable","original"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n"]},"metadata":{},"sourceType":"script"}