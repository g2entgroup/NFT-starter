{"ast":null,"code":"import { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport * as Block from 'multiformats/block';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport { Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL, GATEWAY } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\n\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft;\n    /** @readonly */\n\n    this.url = url;\n    /** @readonly */\n\n    this.data = data;\n    Object.defineProperties(this, {\n      ipnft: {\n        enumerable: true,\n        writable: false\n      },\n      url: {\n        enumerable: true,\n        writable: false\n      },\n      data: {\n        enumerable: false,\n        writable: false\n      }\n    });\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n\n\n  embed() {\n    return Token.embed(this);\n  }\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n\n\n  static embed(_ref) {\n    let {\n      data\n    } = _ref;\n    return embed(data, {\n      gateway: GATEWAY\n    });\n  }\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n\n\n  static async encode(input) {\n    const blockstore = new Blockstore();\n    const [blobs, meta] = mapTokenInputBlobs(input);\n    /** @type {EncodedBlobUrl<T>} */\n\n    const data = JSON.parse(JSON.stringify(meta));\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n\n    const dag = JSON.parse(JSON.stringify(meta));\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob';\n      /** @type {import('./platform.js').ReadableStream} */\n\n      const content = blob.stream();\n      const {\n        root: cid\n      } = await pack({\n        input: [{\n          path: name,\n          content\n        }],\n        blockstore,\n        wrapWithDirectory: true\n      });\n      const href = new URL(`ipfs://${cid}/${name}`);\n      const path = dotPath.split('.');\n      setIn(data, path, href);\n      setIn(dag, path, cid);\n    }\n\n    const {\n      root: metadataJsonCid\n    } = await pack({\n      input: [{\n        path: 'metadata.json',\n        content: JSON.stringify(data)\n      }],\n      blockstore,\n      wrapWithDirectory: false\n    });\n    const block = await Block.encode({\n      value: { ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft'\n      },\n      codec: dagCbor,\n      hasher: sha256\n    });\n    await blockstore.put(block.cid, block.bytes);\n    return {\n      cid: block.cid,\n      token: new Token(block.cid.toString(), `ipfs://${block.cid}/metadata.json`, data),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore)\n    };\n  }\n\n}\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\n\nexport const embed = (input, options) => mapWith(input, isURL, embedURL, options);\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\n\nexport const decode = (_ref2, paths) => {\n  let {\n    ipnft,\n    url,\n    data\n  } = _ref2;\n  return new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths));\n};\n/**\n * @param {any} value\n * @returns {value is URL}\n */\n\nconst isURL = value => value instanceof URL;\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\n\n\nconst decodeURL = (state, url) => [state, new URL(url)];\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\n\n\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)];\n/**\n * @param {any} value\n * @returns {value is object}\n */\n\n\nconst isObject = value => typeof value === 'object' && value != null;\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\n\n\nconst isEncodedURL = (value, assetPaths, path) => typeof value === 'string' && assetPaths.has(path.join('.'));\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\n\n\nexport const encode = input => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n  const form = new FormData();\n\n  for (const [k, v] of map.entries()) {\n    form.set(k, v);\n  }\n\n  form.set('meta', JSON.stringify(meta));\n  return form;\n};\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\n\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob);\n  return [data, undefined];\n};\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\n\n\nconst isBlob = value => value instanceof Blob;\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\n\n\nconst mapTokenInputBlobs = input => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n};\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\n\n\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, []);\n  return output;\n};\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\n\nconst mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject(input) ? mapObjectWith(input, p, f, state, path) : [state,\n/** @type {any} */\ninput];\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\n\n\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init;\n  const output =\n  /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */\n  {};\n\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key]); // @ts-ignore\n\n    output[key] = out;\n    state = next;\n  }\n\n  return [state, output];\n};\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\n\n\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output =\n  /** @type {unknown[]} */\n  [];\n  let state = init;\n\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);\n    output[index] = out;\n    state = next;\n  }\n\n  return [state,\n  /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */\n  output];\n};\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\n\n\nconst setIn = (object, path, value) => {\n  const n = path.length - 1;\n  let target = object;\n\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value;\n    } else {\n      target = target[key];\n    }\n  }\n};","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/nft.storage/src/token.js"],"names":["pack","CID","Block","sha256","dagCbor","Blob","FormData","Blockstore","toGatewayURL","GATEWAY","BlockstoreCarReader","Token","constructor","ipnft","url","data","Object","defineProperties","enumerable","writable","embed","gateway","encode","input","blockstore","blobs","meta","mapTokenInputBlobs","JSON","parse","stringify","dag","dotPath","blob","entries","name","content","stream","root","cid","path","wrapWithDirectory","href","URL","split","setIn","metadataJsonCid","block","value","type","codec","hasher","put","bytes","token","toString","car","options","mapWith","isURL","embedURL","decode","paths","isEncodedURL","decodeURL","state","context","isObject","assetPaths","has","join","map","mapValueWith","isBlob","encodeBlob","Map","form","k","v","set","undefined","p","f","output","Array","isArray","mapArrayWith","mapObjectWith","init","key","next","out","index","element","object","n","length","target"],"mappings":"AAAA,SAASA,IAAT,QAAqB,eAArB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,oBAAvB;AACA,SAASC,MAAT,QAAuB,0BAAvB;AACA,OAAO,KAAKC,OAAZ,MAAyB,gBAAzB;AACA,SAASC,IAAT,EAAeC,QAAf,EAAyBC,UAAzB,QAA2C,eAA3C;AACA,SAASC,YAAT,EAAuBC,OAAvB,QAAsC,cAAtC;AACA,SAASC,mBAAT,QAAoC,oBAApC;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,KAAN,CAAY;AACjB;AACF;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,KAAD,EAAQC,GAAR,EAAaC,IAAb,EAAmB;AAC5B;AACA,SAAKF,KAAL,GAAaA,KAAb;AACA;;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA;;AACA,SAAKC,IAAL,GAAYA,IAAZ;AAEAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5BJ,MAAAA,KAAK,EAAE;AAAEK,QAAAA,UAAU,EAAE,IAAd;AAAoBC,QAAAA,QAAQ,EAAE;AAA9B,OADqB;AAE5BL,MAAAA,GAAG,EAAE;AAAEI,QAAAA,UAAU,EAAE,IAAd;AAAoBC,QAAAA,QAAQ,EAAE;AAA9B,OAFuB;AAG5BJ,MAAAA,IAAI,EAAE;AAAEG,QAAAA,UAAU,EAAE,KAAd;AAAqBC,QAAAA,QAAQ,EAAE;AAA/B;AAHsB,KAA9B;AAKD;AACD;AACF;AACA;;;AACEC,EAAAA,KAAK,GAAG;AACN,WAAOT,KAAK,CAACS,KAAN,CAAY,IAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACc,SAALA,KAAK,OAAW;AAAA,QAAV;AAAEL,MAAAA;AAAF,KAAU;AACrB,WAAOK,KAAK,CAACL,IAAD,EAAO;AAAEM,MAAAA,OAAO,EAAEZ;AAAX,KAAP,CAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,eAANa,MAAM,CAACC,KAAD,EAAQ;AACzB,UAAMC,UAAU,GAAG,IAAIjB,UAAJ,EAAnB;AACA,UAAM,CAACkB,KAAD,EAAQC,IAAR,IAAgBC,kBAAkB,CAACJ,KAAD,CAAxC;AACA;;AACA,UAAMR,IAAI,GAAGa,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeJ,IAAf,CAAX,CAAb;AACA;;AACA,UAAMK,GAAG,GAAGH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeJ,IAAf,CAAX,CAAZ;;AAEA,SAAK,MAAM,CAACM,OAAD,EAAUC,IAAV,CAAX,IAA8BR,KAAK,CAACS,OAAN,EAA9B,EAA+C;AAC7C;AACA;AACA,YAAMC,IAAI,GAAGF,IAAI,CAACE,IAAL,IAAa,MAA1B;AACA;;AACA,YAAMC,OAAO,GAAGH,IAAI,CAACI,MAAL,EAAhB;AACA,YAAM;AAAEC,QAAAA,IAAI,EAAEC;AAAR,UAAgB,MAAMvC,IAAI,CAAC;AAC/BuB,QAAAA,KAAK,EAAE,CAAC;AAAEiB,UAAAA,IAAI,EAAEL,IAAR;AAAcC,UAAAA;AAAd,SAAD,CADwB;AAE/BZ,QAAAA,UAF+B;AAG/BiB,QAAAA,iBAAiB,EAAE;AAHY,OAAD,CAAhC;AAMA,YAAMC,IAAI,GAAG,IAAIC,GAAJ,CAAS,UAASJ,GAAI,IAAGJ,IAAK,EAA9B,CAAb;AACA,YAAMK,IAAI,GAAGR,OAAO,CAACY,KAAR,CAAc,GAAd,CAAb;AACAC,MAAAA,KAAK,CAAC9B,IAAD,EAAOyB,IAAP,EAAaE,IAAb,CAAL;AACAG,MAAAA,KAAK,CAACd,GAAD,EAAMS,IAAN,EAAYD,GAAZ,CAAL;AACD;;AAED,UAAM;AAAED,MAAAA,IAAI,EAAEQ;AAAR,QAA4B,MAAM9C,IAAI,CAAC;AAC3CuB,MAAAA,KAAK,EAAE,CAAC;AAAEiB,QAAAA,IAAI,EAAE,eAAR;AAAyBJ,QAAAA,OAAO,EAAER,IAAI,CAACE,SAAL,CAAef,IAAf;AAAlC,OAAD,CADoC;AAE3CS,MAAAA,UAF2C;AAG3CiB,MAAAA,iBAAiB,EAAE;AAHwB,KAAD,CAA5C;AAMA,UAAMM,KAAK,GAAG,MAAM7C,KAAK,CAACoB,MAAN,CAAa;AAC/B0B,MAAAA,KAAK,EAAE,EACL,GAAGjB,GADE;AAEL,yBAAiBe,eAFZ;AAGLG,QAAAA,IAAI,EAAE;AAHD,OADwB;AAM/BC,MAAAA,KAAK,EAAE9C,OANwB;AAO/B+C,MAAAA,MAAM,EAAEhD;AAPuB,KAAb,CAApB;AASA,UAAMqB,UAAU,CAAC4B,GAAX,CAAeL,KAAK,CAACR,GAArB,EAA0BQ,KAAK,CAACM,KAAhC,CAAN;AAEA,WAAO;AACLd,MAAAA,GAAG,EAAEQ,KAAK,CAACR,GADN;AAELe,MAAAA,KAAK,EAAE,IAAI3C,KAAJ,CACLoC,KAAK,CAACR,GAAN,CAAUgB,QAAV,EADK,EAEJ,UAASR,KAAK,CAACR,GAAI,gBAFf,EAGLxB,IAHK,CAFF;AAOLyC,MAAAA,GAAG,EAAE,IAAI9C,mBAAJ,CAAwB,CAAxB,EAA2B,CAACqC,KAAK,CAACR,GAAP,CAA3B,EAAwCf,UAAxC;AAPA,KAAP;AASD;;AAjHgB;AAoHnB;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMJ,KAAK,GAAG,CAACG,KAAD,EAAQkC,OAAR,KACnBC,OAAO,CAACnC,KAAD,EAAQoC,KAAR,EAAeC,QAAf,EAAyBH,OAAzB,CADF;AAGP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMI,MAAM,GAAG,QAAuBC,KAAvB;AAAA,MAAC;AAAEjD,IAAAA,KAAF;AAASC,IAAAA,GAAT;AAAcC,IAAAA;AAAd,GAAD;AAAA,SACpB,IAAIJ,KAAJ,CAAUE,KAAV,EAAiBC,GAAjB,EAAsB4C,OAAO,CAAC3C,IAAD,EAAOgD,YAAP,EAAqBC,SAArB,EAAgCF,KAAhC,CAA7B,CADoB;AAAA,CAAf;AAGP;AACA;AACA;AACA;;AACA,MAAMH,KAAK,GAAIX,KAAD,IAAWA,KAAK,YAAYL,GAA1C;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMqB,SAAS,GAAG,CAACC,KAAD,EAAQnD,GAAR,KAAgB,CAACmD,KAAD,EAAQ,IAAItB,GAAJ,CAAQ7B,GAAR,CAAR,CAAlC;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAM8C,QAAQ,GAAG,CAACM,OAAD,EAAUpD,GAAV,KAAkB,CAACoD,OAAD,EAAU1D,YAAY,CAACM,GAAD,EAAMoD,OAAN,CAAtB,CAAnC;AAEA;AACA;AACA;AACA;;;AACA,MAAMC,QAAQ,GAAInB,KAAD,IAAW,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAAlE;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMe,YAAY,GAAG,CAACf,KAAD,EAAQoB,UAAR,EAAoB5B,IAApB,KACnB,OAAOQ,KAAP,KAAiB,QAAjB,IAA6BoB,UAAU,CAACC,GAAX,CAAe7B,IAAI,CAAC8B,IAAL,CAAU,GAAV,CAAf,CAD/B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMhD,MAAM,GAAIC,KAAD,IAAW;AAC/B,QAAM,CAACgD,GAAD,EAAM7C,IAAN,IAAc8C,YAAY,CAACjD,KAAD,EAAQkD,MAAR,EAAgBC,UAAhB,EAA4B,IAAIC,GAAJ,EAA5B,EAAuC,EAAvC,CAAhC;AACA,QAAMC,IAAI,GAAG,IAAItE,QAAJ,EAAb;;AACA,OAAK,MAAM,CAACuE,CAAD,EAAIC,CAAJ,CAAX,IAAqBP,GAAG,CAACrC,OAAJ,EAArB,EAAoC;AAClC0C,IAAAA,IAAI,CAACG,GAAL,CAASF,CAAT,EAAYC,CAAZ;AACD;;AACDF,EAAAA,IAAI,CAACG,GAAL,CAAS,MAAT,EAAiBnD,IAAI,CAACE,SAAL,CAAeJ,IAAf,CAAjB;AACA,SAAOkD,IAAP;AACD,CARM;AAUP;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMF,UAAU,GAAG,CAAC3D,IAAD,EAAOkB,IAAP,EAAaO,IAAb,KAAsB;AACvCzB,EAAAA,IAAI,CAACgE,GAAL,CAASvC,IAAI,CAAC8B,IAAL,CAAU,GAAV,CAAT,EAAyBrC,IAAzB;AACA,SAAO,CAAClB,IAAD,EAAOiE,SAAP,CAAP;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACA,MAAMP,MAAM,GAAIzB,KAAD,IAAWA,KAAK,YAAY3C,IAA3C;AAEA;AACA;AACA;AACA;;;AACA,MAAMsB,kBAAkB,GAAIJ,KAAD,IAAW;AACpC,SAAOiD,YAAY,CAACjD,KAAD,EAAQkD,MAAR,EAAgBC,UAAhB,EAA4B,IAAIC,GAAJ,EAA5B,EAAuC,EAAvC,CAAnB;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMjB,OAAO,GAAG,CAACnC,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcjB,KAAd,KAAwB;AAC7C,QAAM,GAAGkB,MAAH,IAAaX,YAAY,CAACjD,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcjB,KAAd,EAAqB,EAArB,CAA/B;AACA,SAAOkB,MAAP;AACD,CAHM;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMX,YAAY,GAAG,CAACjD,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcjB,KAAd,EAAqBzB,IAArB,KACnByC,CAAC,CAAC1D,KAAD,EAAQ0C,KAAR,EAAezB,IAAf,CAAD,GACI0C,CAAC,CAACjB,KAAD,EAAQ1C,KAAR,EAAeiB,IAAf,CADL,GAEI4C,KAAK,CAACC,OAAN,CAAc9D,KAAd,IACA+D,YAAY,CAAC/D,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcjB,KAAd,EAAqBzB,IAArB,CADZ,GAEA2B,QAAQ,CAAC5C,KAAD,CAAR,GACAgE,aAAa,CAAChE,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcjB,KAAd,EAAqBzB,IAArB,CADb,GAEA,CAACyB,KAAD;AAAQ;AAAoB1C,KAA5B,CAPN;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgE,aAAa,GAAG,CAAChE,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcM,IAAd,EAAoBhD,IAApB,KAA6B;AACjD,MAAIyB,KAAK,GAAGuB,IAAZ;AACA,QAAML,MAAM;AACV;AAAkE,IADpE;;AAEA,OAAK,MAAM,CAACM,GAAD,EAAMzC,KAAN,CAAX,IAA2BhC,MAAM,CAACkB,OAAP,CAAeX,KAAf,CAA3B,EAAkD;AAChD,UAAM,CAACmE,IAAD,EAAOC,GAAP,IAAcnB,YAAY,CAACxB,KAAD,EAAQiC,CAAR,EAAWC,CAAX,EAAcjB,KAAd,EAAqB,CAAC,GAAGzB,IAAJ,EAAUiD,GAAV,CAArB,CAAhC,CADgD,CAEhD;;AACAN,IAAAA,MAAM,CAACM,GAAD,CAAN,GAAcE,GAAd;AACA1B,IAAAA,KAAK,GAAGyB,IAAR;AACD;;AACD,SAAO,CAACzB,KAAD,EAAQkB,MAAR,CAAP;AACD,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,YAAY,GAAG,CAAC/D,KAAD,EAAQ0D,CAAR,EAAWC,CAAX,EAAcM,IAAd,EAAoBhD,IAApB,KAA6B;AAChD,QAAM2C,MAAM;AAAG;AAA0B,IAAzC;AAEA,MAAIlB,KAAK,GAAGuB,IAAZ;;AACA,OAAK,MAAM,CAACI,KAAD,EAAQC,OAAR,CAAX,IAA+BtE,KAAK,CAACW,OAAN,EAA/B,EAAgD;AAC9C,UAAM,CAACwD,IAAD,EAAOC,GAAP,IAAcnB,YAAY,CAACqB,OAAD,EAAUZ,CAAV,EAAaC,CAAb,EAAgBjB,KAAhB,EAAuB,CAAC,GAAGzB,IAAJ,EAAUoD,KAAV,CAAvB,CAAhC;AACAT,IAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBD,GAAhB;AACA1B,IAAAA,KAAK,GAAGyB,IAAR;AACD;;AAED,SAAO,CACLzB,KADK;AAEL;AAAkEkB,EAAAA,MAF7D,CAAP;AAID,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMtC,KAAK,GAAG,CAACiD,MAAD,EAAStD,IAAT,EAAeQ,KAAf,KAAyB;AACrC,QAAM+C,CAAC,GAAGvD,IAAI,CAACwD,MAAL,GAAc,CAAxB;AACA,MAAIC,MAAM,GAAGH,MAAb;;AACA,OAAK,IAAI,CAACF,KAAD,EAAQH,GAAR,CAAT,IAAyBjD,IAAI,CAACN,OAAL,EAAzB,EAAyC;AACvC,QAAI0D,KAAK,KAAKG,CAAd,EAAiB;AACfE,MAAAA,MAAM,CAACR,GAAD,CAAN,GAAczC,KAAd;AACD,KAFD,MAEO;AACLiD,MAAAA,MAAM,GAAGA,MAAM,CAACR,GAAD,CAAf;AACD;AACF;AACF,CAVD","sourcesContent":["import { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Block from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      const content = blob.stream()\n      const { root: cid } = await pack({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await pack({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: dagCbor,\n      hasher: sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}