{"ast":null,"code":"import { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n\n  get version() {\n    return this._version;\n  }\n\n  async getRoots() {\n    return this._roots;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n\n}\n\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {\n    version,\n    roots\n  } = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/@ipld/car/esm/lib/indexer.js"],"names":["asyncIterableReader","bytesReader","createDecoder","CarIndexer","constructor","version","roots","iterator","_version","_roots","_iterator","getRoots","Symbol","asyncIterator","fromBytes","bytes","Uint8Array","TypeError","decodeIndexerComplete","fromIterable","asyncIterable","reader","decoder","header","blocksIndex"],"mappings":"AAAA,SACEA,mBADF,EAEEC,WAFF,EAGEC,aAHF,QAIO,cAJP;AAKA,OAAO,MAAMC,UAAN,CAAiB;AACtBC,EAAAA,WAAW,CAACC,OAAD,EAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AACpC,SAAKC,QAAL,GAAgBH,OAAhB;AACA,SAAKI,MAAL,GAAcH,KAAd;AACA,SAAKI,SAAL,GAAiBH,QAAjB;AACD;;AACU,MAAPF,OAAO,GAAG;AACZ,WAAO,KAAKG,QAAZ;AACD;;AACa,QAARG,QAAQ,GAAG;AACf,WAAO,KAAKF,MAAZ;AACD;;AACoB,GAApBG,MAAM,CAACC,aAAa,IAAI;AACvB,WAAO,KAAKH,SAAZ;AACD;;AACqB,eAATI,SAAS,CAACC,KAAD,EAAQ;AAC5B,QAAI,EAAEA,KAAK,YAAYC,UAAnB,CAAJ,EAAoC;AAClC,YAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;;AACD,WAAOC,qBAAqB,CAACjB,WAAW,CAACc,KAAD,CAAZ,CAA5B;AACD;;AACwB,eAAZI,YAAY,CAACC,aAAD,EAAgB;AACvC,QAAI,CAACA,aAAD,IAAkB,EAAE,OAAOA,aAAa,CAACR,MAAM,CAACC,aAAR,CAApB,KAA+C,UAAjD,CAAtB,EAAoF;AAClF,YAAM,IAAII,SAAJ,CAAc,2CAAd,CAAN;AACD;;AACD,WAAOC,qBAAqB,CAAClB,mBAAmB,CAACoB,aAAD,CAApB,CAA5B;AACD;;AA1BqB;;AA4BxB,eAAeF,qBAAf,CAAqCG,MAArC,EAA6C;AAC3C,QAAMC,OAAO,GAAGpB,aAAa,CAACmB,MAAD,CAA7B;AACA,QAAM;AAAChB,IAAAA,OAAD;AAAUC,IAAAA;AAAV,MAAmB,MAAMgB,OAAO,CAACC,MAAR,EAA/B;AACA,SAAO,IAAIpB,UAAJ,CAAeE,OAAf,EAAwBC,KAAxB,EAA+BgB,OAAO,CAACE,WAAR,EAA/B,CAAP;AACD","sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}"]},"metadata":{},"sourceType":"module"}