{"ast":null,"code":"var _jsxFileName = \"/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/src/App.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from \"react\";\n/* ERC71 based Solidity Contract Interface */\n\nimport filecoinNFTHack from \"./utils/FilecoinNFTHack.json\";\n/* NFT.Storage import for creating an IPFS CID & storing with Filecoin */\n\nimport { NFTStorage, File } from \"nft.storage\";\nimport { baseSVG } from \"./utils/BaseSVG\";\n/* Javascript Lib for evm-compatible blockchain contracts */\n\nimport { ethers } from \"ethers\";\n/* UI Components & Style*/\n\nimport \"./styles/App.css\";\nimport Layout from \"./components/Layout\";\nimport MintNFTInput from \"./components/MintNFTInput\";\nimport Status from \"./components/Status\";\nimport ImagePreview from \"./components/ImagePreview\";\nimport Link from \"./components/Link\";\nimport DisplayLinks from \"./components/DisplayLinks\";\nimport ConnectWalletButton from \"./components/ConnectWalletButton\";\nimport NFTViewer from \"./components/NFTViewer\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst INITIAL_LINK_STATE = {\n  etherscan: \"\",\n  opensea: \"\",\n  rarible: \"\"\n};\nconst INITIAL_TRANSACTION_STATE = {\n  loading: \"\",\n  error: \"\",\n  success: \"\",\n  warning: \"\"\n};\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS;\n\nconst App = () => {\n  _s();\n\n  const [currentAccount, setCurrentAccount] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  const [linksObj, setLinksObj] = useState(INITIAL_LINK_STATE);\n  const [imageView, setImageView] = useState(\"\");\n  const [remainingNFTs, setRemainingNFTs] = useState(\"\");\n  const [nftCollectionData, setNftCollectionData] = useState(\"\");\n  const [recentlyMinted, setRecentlyMinted] = useState(\"\");\n  const [transactionState, setTransactionState] = useState(INITIAL_TRANSACTION_STATE);\n  const {\n    loading,\n    error,\n    success\n  } = transactionState; //make it easier\n\n  /* runs on page load - checks wallet is connected */\n\n  useEffect(() => {\n    checkIfWalletIsConnected();\n  }, []);\n  /* If a wallet is connected, do some setup */\n\n  useEffect(() => {\n    setUpEventListener();\n    fetchNFTCollection();\n  }, [currentAccount]);\n  /* Check for a wallet */\n\n  const checkIfWalletIsConnected = async () => {\n    const {\n      ethereum\n    } = window;\n\n    if (!ethereum) {\n      console.log(\"Make sure you have metamask!\");\n      return;\n    } else {\n      console.log(\"We have the ethereum object\", ethereum);\n      setUpEventListener();\n    }\n\n    const accounts = await ethereum.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts.length !== 0) {\n      setCurrentAccount(accounts[0]);\n    } else {\n      console.log(\"No authorized account found\");\n    } //TODO: make sure on right network or change programatically\n    // let chainId = await ethereum.request({ method: 'eth_chainId' });\n    // console.log(\"Connected to chain \" + chainId);\n    // // String, hex code of the chainId of the Rinkebey test network\n    // const rinkebyChainId = \"0x4\";\n    // if (chainId !== rinkebyChainId) {\n    //   alert(\"You are not connected to the Rinkeby Test Network!\");\n    // }\n\n  };\n  /* Connect a wallet */\n\n\n  const connectWallet = async () => {\n    try {\n      const {\n        ethereum\n      } = window;\n\n      if (!ethereum) {\n        alert(\"Get MetaMask!\");\n        return;\n      }\n\n      const accounts = await ethereum.request({\n        method: \"eth_requestAccounts\"\n      });\n      console.log(\"Connected\", accounts[0]);\n      setCurrentAccount(accounts[0]);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  /* Listens for events emitted from the solidity contract, to render data accurately */\n\n\n  const setUpEventListener = async () => {\n    try {\n      const {\n        ethereum\n      } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(CONTRACT_ADDRESS, filecoinNFTHack.abi, signer);\n        connectedContract.on(\"RemainingMintableNFTChange\", remainingNFTs => {\n          setRemainingNFTs(remainingNFTs);\n        });\n        connectedContract.on(\"NewFilecoinNFTMinted\", (sender, tokenId, tokenURI) => {\n          console.log(\"event - new minted NFT\");\n          fetchNFTCollection();\n        });\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  /* Helper function for createNFTData */\n\n\n  const resetState = () => {\n    setLinksObj(INITIAL_LINK_STATE);\n    setName(\"\");\n    setImageView(\"\");\n  };\n  /* Helper function for createNFTData */\n\n\n  const createImageView = metadata => {\n    let imgViewArray = metadata.data.image.pathname.split(\"/\");\n    let imgViewString = `https://${imgViewArray[2]}.ipfs.dweb.link/${imgViewArray[3]}`;\n    setImageView(imgViewString);\n    console.log(\"image view set\", `https://${imgViewArray[2]}.ipfs.dweb.link/${imgViewArray[3]}`);\n  };\n  /* Create the IPFS CID of the json data */\n\n\n  const createNFTData = async () => {\n    console.log(\"saving to NFT storage\");\n    resetState();\n    setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n      loading: \"Saving NFT data to NFT.Storage...\"\n    }); // install it\n    // Set Up the NFT.Storage Client\n\n    const client = new NFTStorage({\n      token: process.env.REACT_APP_NFT_STORAGE_API_KEY\n    }); //lets load up this token with some metadata and our image and save it to NFT.storage\n    //image contains any File or Blob you want to save\n    //name, image, description, other traits.\n    // useBlob to save one item to IPFS\n    // use File to save all the json metadata needed - much like any object storage you're familiar with!\n\n    try {\n      await client.store({\n        name: `${name}: Filecoin @ NFTHack 2022`,\n        description: \"NFT created for EthGlobal NFTHack 2022 and limited to 100 personalised tokens\",\n        image: new File([`${baseSVG}${name}</text>\n      </svg>`], `FilecoinNFTHack.svg`, {\n          type: \"image/svg+xml\"\n        }),\n        traits: {\n          awesomeness: \"100\" //probs should use 0-1 for solidity\n\n        }\n      }).then(metadata => {\n        setTransactionState({ ...transactionState,\n          success: \"Saved NFT data to NFT.Storage...!! We created an IPFS CID & made a Filecoin Storage Deal with one call!\",\n          loading: \"\"\n        });\n        console.log(\"metadata saved\", metadata); // To view the data we just saved in the browser we need to use an IPFS http bridge\n        // Or Brave Browser which has IPFS integration built into it\n        // Or run a local IPFS node (there's a desktop app)\n        // This means manipulating the returned CID to configure it for a gateway...\n        // Check gateways & their functionality here: https://ipfs.github.io/public-gateway-checker/\n\n        createImageView(metadata); //we can also check the status of our data using this\n        // const status = await client.status(metadata.ipnft);\n        // console.log(\"status\", status);\n        // Now that we have a CID and our data is stored on Filecoin, \n        // - we'll mint the NFT with the token data (and IPFS CID)\n\n        askContractToMintNft(metadata.url);\n      });\n    } catch (error) {\n      console.log(\"Could not save NFT to NFT.Storage - Aborted minting\");\n      setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n        error: \"Could not save NFT to NFT.Storage - Aborted minting\"\n      });\n    }\n  };\n  /* Mint the NFT on the eth blockchain */\n\n\n  const askContractToMintNft = async IPFSurl => {\n    //should check the wallet chain is correct here\n    setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n      loading: \"Approving & minting NFT...\"\n    });\n\n    try {\n      const {\n        ethereum\n      } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(CONTRACT_ADDRESS, filecoinNFTHack.abi, signer);\n        console.log(\"Opening wallet\");\n        let nftTxn = await connectedContract.mintMyNFT(IPFSurl);\n        connectedContract.on(\"NewFilecoinNFTMinted\", (from, tokenId, tokenURI) => {\n          console.log(\"event listener\", from, tokenId.toNumber(), tokenURI);\n          setLinksObj({ ...linksObj,\n            opensea: `https://testnets.opensea.io/assets/${CONTRACT_ADDRESS}/${tokenId.toNumber()}`,\n            rarible: `https://rinkeby.rarible.com/token/${CONTRACT_ADDRESS}:${tokenId.toNumber()}`,\n            etherscan: `https://rinkeby.etherscan.io/tx/${nftTxn.hash}`\n          });\n        }); //SHOULD UPDATE IMAGELINK to returned value\n\n        await nftTxn.wait();\n        setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n          success: \"NFT Minted!\"\n        });\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n        setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n          error: `No Wallet connected`\n        });\n      }\n    } catch (error) {\n      setTransactionState({ ...INITIAL_TRANSACTION_STATE,\n        error: `Error Minting NFT. ${error.message}`\n      });\n    }\n  };\n  /* Helper function - manipulating the returned CID into a http link using IPFS gateway */\n\n\n  const createIPFSgatewayLink = el => {\n    let link = el[1].split(\"/\");\n    let fetchURL = `https://${link[2]}.ipfs.dweb.link/${link[3]}`;\n    return fetchURL;\n  };\n  /* \n    Helper function for fetching the Filecoin data through IPFS gateways \n    to display the images in the UI \n  */\n\n\n  const createImageURLsForRetrieval = async collection => {\n    let dataCollection = collection.slice().reverse().slice(0, 5).map(el => {\n      return el;\n    });\n    let imgURLs = await Promise.all(dataCollection.map(async el => {\n      const ipfsGatewayLink = createIPFSgatewayLink(el); // let link = el[1].split(\"/\");\n      // let fetchURL = `https://${link[2]}.ipfs.dweb.link/${link[3]}`;\n\n      console.log(\"fetchURL\", ipfsGatewayLink);\n      const response = await fetch(ipfsGatewayLink //     {\n      //     method : \"GET\",\n      //     mode: 'cors',\n      //     type: 'cors',\n      //     headers: {}\n      // }\n      );\n      const json = await response.json(); // console.log(\"Responsejson\", json)\n\n      return json;\n    }));\n    console.log(\"imgURLs2\", imgURLs);\n    setRecentlyMinted(imgURLs);\n  };\n  /* Function to get our collection Data from\n     1. The blockchain\n     2. Filecoin via IPFS addressing & http gateways\n  */\n\n\n  const fetchNFTCollection = async () => {\n    console.log(\"fetching nft collection\");\n\n    try {\n      const {\n        ethereum\n      } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(CONTRACT_ADDRESS, filecoinNFTHack.abi, signer);\n        let remainingNFTs = await connectedContract.remainingMintableNFTs();\n        setRemainingNFTs(remainingNFTs.toNumber()); //update state\n\n        let collection = await connectedContract.getNFTCollection();\n        setNftCollectionData(collection); //update state\n\n        console.log(\"collection\", collection);\n        /***\n         * Going to put these in the view collection\n         */\n\n        await createImageURLsForRetrieval(collection);\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  /* Render our page */\n\n\n  return /*#__PURE__*/_jsxDEV(Layout, {\n    connected: currentAccount === \"\",\n    connectWallet: connectWallet,\n    children: /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"sub-sub-text\",\n        children: `Remaining NFT's: ${remainingNFTs}`\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 9\n      }, this), transactionState !== INITIAL_TRANSACTION_STATE && /*#__PURE__*/_jsxDEV(Status, {\n        transactionState: transactionState\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 382,\n        columnNumber: 60\n      }, this), imageView && !linksObj.etherscan && /*#__PURE__*/_jsxDEV(Link, {\n        link: imageView,\n        description: \"See IPFS image link\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 34\n      }, this), imageView && /*#__PURE__*/_jsxDEV(ImagePreview, {\n        imgLink: imageView\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 385,\n        columnNumber: 23\n      }, this), linksObj.etherscan && /*#__PURE__*/_jsxDEV(DisplayLinks, {\n        linksObj: linksObj\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 386,\n        columnNumber: 32\n      }, this), currentAccount === \"\" ? /*#__PURE__*/_jsxDEV(ConnectWalletButton, {\n        connectWallet: connectWallet\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 388,\n        columnNumber: 11\n      }, this) : transactionState.loading ? /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 390,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(MintNFTInput, {\n        name: name,\n        setName: setName,\n        transactionState: transactionState,\n        createNFTData: createNFTData\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 392,\n        columnNumber: 11\n      }, this), recentlyMinted && /*#__PURE__*/_jsxDEV(NFTViewer, {\n        recentlyMinted: recentlyMinted\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 394,\n        columnNumber: 28\n      }, this)]\n    }, void 0, true)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 379,\n    columnNumber: 5\n  }, this);\n};\n\n_s(App, \"R2aYGYaXVnORxcgJKEwLEVv8BXI=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/src/App.js"],"names":["React","useState","useEffect","filecoinNFTHack","NFTStorage","File","baseSVG","ethers","Layout","MintNFTInput","Status","ImagePreview","Link","DisplayLinks","ConnectWalletButton","NFTViewer","INITIAL_LINK_STATE","etherscan","opensea","rarible","INITIAL_TRANSACTION_STATE","loading","error","success","warning","CONTRACT_ADDRESS","process","env","REACT_APP_CONTRACT_ADDRESS","App","currentAccount","setCurrentAccount","name","setName","linksObj","setLinksObj","imageView","setImageView","remainingNFTs","setRemainingNFTs","nftCollectionData","setNftCollectionData","recentlyMinted","setRecentlyMinted","transactionState","setTransactionState","checkIfWalletIsConnected","setUpEventListener","fetchNFTCollection","ethereum","window","console","log","accounts","request","method","length","connectWallet","alert","provider","providers","Web3Provider","signer","getSigner","connectedContract","Contract","abi","on","sender","tokenId","tokenURI","resetState","createImageView","metadata","imgViewArray","data","image","pathname","split","imgViewString","createNFTData","client","token","REACT_APP_NFT_STORAGE_API_KEY","store","description","type","traits","awesomeness","then","askContractToMintNft","url","IPFSurl","nftTxn","mintMyNFT","from","toNumber","hash","wait","message","createIPFSgatewayLink","el","link","fetchURL","createImageURLsForRetrieval","collection","dataCollection","slice","reverse","map","imgURLs","Promise","all","ipfsGatewayLink","response","fetch","json","remainingMintableNFTs","getNFTCollection"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\n\n/* ERC71 based Solidity Contract Interface */\nimport filecoinNFTHack from \"./utils/FilecoinNFTHack.json\";\n\n/* NFT.Storage import for creating an IPFS CID & storing with Filecoin */\nimport { NFTStorage, File } from \"nft.storage\";\nimport { baseSVG } from \"./utils/BaseSVG\";\n\n/* Javascript Lib for evm-compatible blockchain contracts */\nimport { ethers } from \"ethers\";\n\n/* UI Components & Style*/\nimport \"./styles/App.css\";\nimport Layout from \"./components/Layout\";\nimport MintNFTInput from \"./components/MintNFTInput\";\nimport Status from \"./components/Status\";\nimport ImagePreview from \"./components/ImagePreview\";\nimport Link from \"./components/Link\";\nimport DisplayLinks from \"./components/DisplayLinks\";\nimport ConnectWalletButton from \"./components/ConnectWalletButton\";\nimport NFTViewer from \"./components/NFTViewer\";\n\nconst INITIAL_LINK_STATE = {\n  etherscan: \"\",\n  opensea: \"\",\n  rarible: \"\",\n};\n\nconst INITIAL_TRANSACTION_STATE = {\n  loading: \"\",\n  error: \"\",\n  success: \"\",\n  warning: \"\",\n};\n\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS;\n\nconst App = () => {\n  const [currentAccount, setCurrentAccount] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  const [linksObj, setLinksObj] = useState(INITIAL_LINK_STATE);\n  const [imageView, setImageView] = useState(\"\");\n  const [remainingNFTs, setRemainingNFTs] = useState(\"\");\n  const [nftCollectionData, setNftCollectionData] = useState(\"\");\n  const [recentlyMinted, setRecentlyMinted] = useState(\"\");\n  const [transactionState, setTransactionState] = useState(\n    INITIAL_TRANSACTION_STATE\n  );\n  const { loading, error, success } = transactionState; //make it easier\n\n  /* runs on page load - checks wallet is connected */\n  useEffect(() => {\n    checkIfWalletIsConnected();\n  }, []);\n\n  /* If a wallet is connected, do some setup */\n  useEffect(() => {\n    setUpEventListener();\n    fetchNFTCollection();\n  }, [currentAccount]);\n\n  /* Check for a wallet */\n  const checkIfWalletIsConnected = async () => {\n    const { ethereum } = window;\n\n    if (!ethereum) {\n      console.log(\"Make sure you have metamask!\");\n      return;\n    } else {\n      console.log(\"We have the ethereum object\", ethereum);\n      setUpEventListener();\n    }\n\n    const accounts = await ethereum.request({ method: \"eth_accounts\" });\n\n    if (accounts.length !== 0) {\n      setCurrentAccount(accounts[0]);\n    } else {\n      console.log(\"No authorized account found\");\n    }\n\n    //TODO: make sure on right network or change programatically\n    // let chainId = await ethereum.request({ method: 'eth_chainId' });\n    // console.log(\"Connected to chain \" + chainId);\n\n    // // String, hex code of the chainId of the Rinkebey test network\n    // const rinkebyChainId = \"0x4\";\n    // if (chainId !== rinkebyChainId) {\n    //   alert(\"You are not connected to the Rinkeby Test Network!\");\n    // }\n  };\n\n  /* Connect a wallet */\n  const connectWallet = async () => {\n    try {\n      const { ethereum } = window;\n\n      if (!ethereum) {\n        alert(\"Get MetaMask!\");\n        return;\n      }\n      const accounts = await ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n      console.log(\"Connected\", accounts[0]);\n      setCurrentAccount(accounts[0]);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  /* Listens for events emitted from the solidity contract, to render data accurately */\n  const setUpEventListener = async () => {\n    try {\n      const { ethereum } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(\n          CONTRACT_ADDRESS,\n          filecoinNFTHack.abi,\n          signer\n        );\n\n        connectedContract.on(\"RemainingMintableNFTChange\", (remainingNFTs) => {\n          setRemainingNFTs(remainingNFTs);\n        });\n        connectedContract.on(\n          \"NewFilecoinNFTMinted\",\n          (sender, tokenId, tokenURI) => {\n            console.log(\"event - new minted NFT\");\n            fetchNFTCollection();\n          }\n        );\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  /* Helper function for createNFTData */\n  const resetState = () => {\n    setLinksObj(INITIAL_LINK_STATE);\n    setName(\"\");\n    setImageView(\"\");\n  }\n\n  /* Helper function for createNFTData */\n  const createImageView = (metadata) => {\n    let imgViewArray = metadata.data.image.pathname.split(\"/\");\n    let imgViewString = `https://${imgViewArray[2]}.ipfs.dweb.link/${imgViewArray[3]}`;\n    setImageView(\n      imgViewString\n    );\n    console.log(\n      \"image view set\",\n      `https://${imgViewArray[2]}.ipfs.dweb.link/${imgViewArray[3]}`\n    );\n  } \n\n  /* Create the IPFS CID of the json data */\n  const createNFTData = async () => {\n    console.log(\"saving to NFT storage\");\n    resetState();\n    setTransactionState({\n      ...INITIAL_TRANSACTION_STATE,\n      loading: \"Saving NFT data to NFT.Storage...\",\n    });\n\n    // install it\n    // Set Up the NFT.Storage Client\n    const client = new NFTStorage({\n      token: process.env.REACT_APP_NFT_STORAGE_API_KEY,\n    });\n\n    //lets load up this token with some metadata and our image and save it to NFT.storage\n    //image contains any File or Blob you want to save\n    //name, image, description, other traits.\n    // useBlob to save one item to IPFS\n    // use File to save all the json metadata needed - much like any object storage you're familiar with!\n    try {\n      await client\n        .store({\n          name: `${name}: Filecoin @ NFTHack 2022`,\n          description:\n            \"NFT created for EthGlobal NFTHack 2022 and limited to 100 personalised tokens\",\n          image: new File(\n            [\n              `${baseSVG}${name}</text>\n      </svg>`,\n            ],\n            `FilecoinNFTHack.svg`,\n            {\n              type: \"image/svg+xml\",\n            }\n          ),\n          traits: {\n            awesomeness: \"100\", //probs should use 0-1 for solidity\n          },\n        })\n        .then((metadata) => {\n          setTransactionState({\n            ...transactionState,\n            success: \"Saved NFT data to NFT.Storage...!! We created an IPFS CID & made a Filecoin Storage Deal with one call!\",\n            loading: \"\",\n          });\n          console.log(\"metadata saved\", metadata);\n\n          // To view the data we just saved in the browser we need to use an IPFS http bridge\n          // Or Brave Browser which has IPFS integration built into it\n          // Or run a local IPFS node (there's a desktop app)\n          // This means manipulating the returned CID to configure it for a gateway...\n          // Check gateways & their functionality here: https://ipfs.github.io/public-gateway-checker/\n          createImageView(metadata);\n          \n          //we can also check the status of our data using this\n          // const status = await client.status(metadata.ipnft);\n          // console.log(\"status\", status);\n\n          // Now that we have a CID and our data is stored on Filecoin, \n          // - we'll mint the NFT with the token data (and IPFS CID)\n          askContractToMintNft(metadata.url);\n        });\n    } catch (error) {\n      console.log(\"Could not save NFT to NFT.Storage - Aborted minting\");\n      setTransactionState({\n        ...INITIAL_TRANSACTION_STATE,\n        error: \"Could not save NFT to NFT.Storage - Aborted minting\",\n      });\n    }\n  };\n\n  /* Mint the NFT on the eth blockchain */\n  const askContractToMintNft = async (IPFSurl) => {\n    //should check the wallet chain is correct here\n    setTransactionState({\n      ...INITIAL_TRANSACTION_STATE,\n      loading: \"Approving & minting NFT...\",\n    });\n\n    try {\n      const { ethereum } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(\n          CONTRACT_ADDRESS,\n          filecoinNFTHack.abi,\n          signer\n        );\n\n        console.log(\"Opening wallet\");\n        let nftTxn = await connectedContract.mintMyNFT(IPFSurl);\n\n        connectedContract.on(\n          \"NewFilecoinNFTMinted\",\n          (from, tokenId, tokenURI) => {\n            console.log(\"event listener\", from, tokenId.toNumber(), tokenURI);\n            setLinksObj({\n              ...linksObj,\n              opensea: `https://testnets.opensea.io/assets/${CONTRACT_ADDRESS}/${tokenId.toNumber()}`,\n              rarible: `https://rinkeby.rarible.com/token/${CONTRACT_ADDRESS}:${tokenId.toNumber()}`,\n              etherscan: `https://rinkeby.etherscan.io/tx/${nftTxn.hash}`,\n            });\n          }\n        );\n\n        //SHOULD UPDATE IMAGELINK to returned value\n        await nftTxn.wait();\n        setTransactionState({\n          ...INITIAL_TRANSACTION_STATE,\n          success: \"NFT Minted!\",\n        });\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n        setTransactionState({\n          ...INITIAL_TRANSACTION_STATE,\n          error: `No Wallet connected`,\n        });\n      }\n    } catch (error) {\n      setTransactionState({\n        ...INITIAL_TRANSACTION_STATE,\n        error: `Error Minting NFT. ${error.message}`,\n      });\n    }\n  };\n\n  /* Helper function - manipulating the returned CID into a http link using IPFS gateway */\n  const createIPFSgatewayLink = (el) => {\n    let link = el[1].split(\"/\");\n    let fetchURL = `https://${link[2]}.ipfs.dweb.link/${link[3]}`;\n    return fetchURL;\n  }\n\n  /* \n    Helper function for fetching the Filecoin data through IPFS gateways \n    to display the images in the UI \n  */\n  const createImageURLsForRetrieval = async (collection) => {\n    let dataCollection = collection\n    .slice()\n    .reverse()\n    .slice(0, 5)\n    .map((el) => {\n      return el;\n    });\n\n    let imgURLs = await Promise.all(\n      dataCollection.map(async (el) => {\n        const ipfsGatewayLink = createIPFSgatewayLink(el);\n        // let link = el[1].split(\"/\");\n        // let fetchURL = `https://${link[2]}.ipfs.dweb.link/${link[3]}`;\n        console.log(\"fetchURL\", ipfsGatewayLink);\n        const response = await fetch(ipfsGatewayLink, \n      //     {\n      //     method : \"GET\",\n      //     mode: 'cors',\n      //     type: 'cors',\n      //     headers: {}\n      // }\n      );\n        const json = await response.json();\n        // console.log(\"Responsejson\", json)\n        return json;\n      })\n    );\n\n    console.log(\"imgURLs2\", imgURLs);\n    setRecentlyMinted(imgURLs);\n  }\n\n /* Function to get our collection Data from\n    1. The blockchain\n    2. Filecoin via IPFS addressing & http gateways\n */\n  const fetchNFTCollection = async () => {\n    console.log(\"fetching nft collection\");\n    try {\n      const { ethereum } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const connectedContract = new ethers.Contract(\n          CONTRACT_ADDRESS,\n          filecoinNFTHack.abi,\n          signer\n        );\n\n        let remainingNFTs = await connectedContract.remainingMintableNFTs();\n        setRemainingNFTs(remainingNFTs.toNumber()); //update state\n\n        let collection = await connectedContract.getNFTCollection();\n        setNftCollectionData(collection); //update state\n        console.log(\"collection\", collection);\n\n        /***\n         * Going to put these in the view collection\n         */\n        await createImageURLsForRetrieval(collection);\n\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n\n  /* Render our page */\n  return (\n    <Layout connected={currentAccount === \"\"} connectWallet={connectWallet}>\n      <>\n        <p className=\"sub-sub-text\">{`Remaining NFT's: ${remainingNFTs}`}</p>\n        {transactionState !== INITIAL_TRANSACTION_STATE && <Status transactionState={transactionState}/>}\n        {imageView &&\n          !linksObj.etherscan && <Link link={imageView} description=\"See IPFS image link\"/>}\n        {imageView && <ImagePreview imgLink ={imageView}/>}\n        {linksObj.etherscan && <DisplayLinks linksObj={linksObj} />}\n        {currentAccount === \"\" ? (\n          <ConnectWalletButton connectWallet={connectWallet}/>\n        ) : transactionState.loading ? (\n          <div />\n        ) : (\n          <MintNFTInput name={name} setName={setName} transactionState={transactionState} createNFTData={createNFTData}/>\n        )}\n        {recentlyMinted && <NFTViewer recentlyMinted={recentlyMinted}/>}\n      </>\n    </Layout>\n  );\n};\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}