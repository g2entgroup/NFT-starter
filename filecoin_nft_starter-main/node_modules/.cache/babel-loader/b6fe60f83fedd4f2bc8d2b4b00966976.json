{"ast":null,"code":"import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\n\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n\n    async writeBlock(block) {\n      const {\n        cid,\n        bytes\n      } = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n\n    async close() {\n      return writer.end();\n    }\n\n  };\n}\n\nexport { createEncoder };","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/@ipld/car/esm/lib/encoder.js"],"names":["varint","encode","dagCborEncode","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAASC,MAAM,IAAIC,aAAnB,QAAwC,gBAAxC;AACA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,QAAMC,WAAW,GAAGH,aAAa,CAAC;AAChCI,IAAAA,OAAO,EAAE,CADuB;AAEhCF,IAAAA;AAFgC,GAAD,CAAjC;AAIA,QAAMG,WAAW,GAAGP,MAAM,CAACC,MAAP,CAAcI,WAAW,CAACG,MAA1B,CAApB;AACA,QAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAeH,WAAW,CAACC,MAAZ,GAAqBH,WAAW,CAACG,MAAhD,CAAf;AACAC,EAAAA,MAAM,CAACE,GAAP,CAAWJ,WAAX,EAAwB,CAAxB;AACAE,EAAAA,MAAM,CAACE,GAAP,CAAWN,WAAX,EAAwBE,WAAW,CAACC,MAApC;AACA,SAAOC,MAAP;AACD;;AACD,SAASG,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,SAAO;AACL,UAAMC,QAAN,CAAeV,KAAf,EAAsB;AACpB,YAAMW,KAAK,GAAGZ,YAAY,CAACC,KAAD,CAA1B;AACA,YAAMS,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;AACD,KAJI;;AAKL,UAAME,UAAN,CAAiBC,KAAjB,EAAwB;AACtB,YAAM;AAACC,QAAAA,GAAD;AAAMJ,QAAAA;AAAN,UAAeG,KAArB;AACA,YAAML,MAAM,CAACG,KAAP,CAAa,IAAIN,UAAJ,CAAeV,MAAM,CAACC,MAAP,CAAckB,GAAG,CAACJ,KAAJ,CAAUP,MAAV,GAAmBO,KAAK,CAACP,MAAvC,CAAf,CAAb,CAAN;AACA,YAAMK,MAAM,CAACG,KAAP,CAAaG,GAAG,CAACJ,KAAjB,CAAN;;AACA,UAAIA,KAAK,CAACP,MAAV,EAAkB;AAChB,cAAMK,MAAM,CAACG,KAAP,CAAaD,KAAb,CAAN;AACD;AACF,KAZI;;AAaL,UAAMK,KAAN,GAAc;AACZ,aAAOP,MAAM,CAACQ,GAAP,EAAP;AACD;;AAfI,GAAP;AAiBD;;AACD,SACET,aADF","sourcesContent":["import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {cid, bytes} = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport {\n  createEncoder\n};"]},"metadata":{},"sourceType":"module"}