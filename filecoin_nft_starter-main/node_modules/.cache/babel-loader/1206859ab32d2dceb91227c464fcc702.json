{"ast":null,"code":"import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\n\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  return block;\n}\n\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\n\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n\n  const version = await readVarint(reader);\n\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\n\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\n\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\n\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    async *blocks() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n\n    async *blocksIndex() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return bytes.subarray(pos, pos + length);\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n\n    while (have < length) {\n      const chunk = await readChunk();\n\n      if (chunk == null) {\n        break;\n      }\n\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n\n      have += chunk.length;\n    }\n\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n\n    offset = 0;\n  };\n\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return currentChunk.subarray(offset, offset + length);\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  async function readChunk() {\n    const next = await iterator.next();\n\n    if (next.done) {\n      return null;\n    }\n\n    return next.value;\n  }\n\n  return chunkReader(readChunk);\n}","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/@ipld/car/esm/lib/decoder.js"],"names":["varint","CID","Digest","decode","decodeDagCbor","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","Object","keys","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","create","codec","readBlockHead","start","pos","cid","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value"],"mappings":"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","sourcesContent":["import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}"]},"metadata":{},"sourceType":"module"}