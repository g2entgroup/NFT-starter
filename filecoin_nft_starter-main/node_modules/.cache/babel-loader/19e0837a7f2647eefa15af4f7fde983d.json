{"ast":null,"code":"async function* _batch(size, iterable) {\n  let dataBatch = [];\n\n  for await (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (size === 0) {\n    return iterable;\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  const values = [];\n\n  for await (const value of iterable) {\n    values.push(value);\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat() {\n  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterables[_key] = arguments[_key];\n  }\n\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  for await (const val of iterable) {// do nothing\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n\n  for (const val of iterable) {// do nothing\n  }\n}\n\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\n\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n\n    if (stream._readableState.ended) {\n      break;\n    }\n\n    await onceReadable(stream);\n  }\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nasync function* merge() {\n  for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    iterables[_key2] = arguments[_key2];\n  }\n\n  const sources = new Set(iterables.map(getIterator));\n\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\n\nfunction pipeline(firstFn) {\n  let previousFn = firstFn();\n\n  for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    fns[_key3 - 1] = arguments[_key3];\n  }\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n\n      yield value;\n    }\n  };\n\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n\n  while (true) {\n    const {\n      value,\n      done\n    } = await itr.next();\n\n    if (done) {\n      break;\n    }\n\n    try {\n      const val = await value.value;\n\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n\n  if (transformError) {\n    throw transformError;\n  }\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nasync function* parallelMerge() {\n  for (var _len4 = arguments.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    iterables[_key4] = arguments[_key4];\n  }\n\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n\n    if (values.size > 0) {\n      return resolve();\n    }\n\n    valueCb = resolve;\n    errCb = reject;\n  });\n\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async _ref => {\n      let {\n        done,\n        value\n      } = _ref;\n\n      if (!done) {\n        values.set(input, value);\n      }\n\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n\n  for (const input of inputs) {\n    queueNext(input);\n  }\n\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n\n    await waitForQueue();\n\n    for (const [input, value] of values) {\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\n\nasync function _reduce(func, start, iterable) {\n  let value = start;\n\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n  let taken = 0;\n\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = await itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n\n    if (lastError) {\n      break;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n}\n\nexport { batch, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, time, transform, writeToStream };","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/streaming-iterables/dist/index.mjs"],"names":["_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","getIterator","next","iterator","TypeError","defer","reject","resolve","promise","Promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","value","done","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","previousFn","fns","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","time","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream"],"mappings":"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","sourcesContent":["async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\n/// <reference lib=\"esnext.asynciterable\" />\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\n/// <reference lib=\"esnext.asynciterable\" />\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, time, transform, writeToStream };\n"]},"metadata":{},"sourceType":"module"}