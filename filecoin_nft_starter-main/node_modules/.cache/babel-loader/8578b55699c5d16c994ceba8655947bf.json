{"ast":null,"code":"import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack(_ref) {\n  let {\n    input,\n    blockstore: userBlockstore,\n    hasher,\n    maxChunkSize,\n    maxChildrenPerNode,\n    wrapWithDirectory,\n    rawLeaves\n  } = _ref;\n\n  if (!input || Array.isArray(input) && !input.length) {\n    throw new Error('missing input file(s)');\n  }\n\n  const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore(); // Consume the source\n\n  const rootEntry = await last(pipe(getNormaliser(input), source => importer(source, blockstore, { ...unixfsImporterOptionsDefault,\n    hasher: hasher || unixfsImporterOptionsDefault.hasher,\n    maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n    maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n    wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n    rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n  })));\n\n  if (!rootEntry || !rootEntry.cid) {\n    throw new Error('given input could not be parsed correctly');\n  }\n\n  const root = rootEntry.cid;\n  const {\n    writer,\n    out: carOut\n  } = await CarWriter.create([root]);\n  const carOutIter = carOut[Symbol.asyncIterator]();\n  let writingPromise;\n\n  const writeAll = async () => {\n    for await (const block of blockstore.blocks()) {\n      // `await` will block until all bytes in `carOut` are consumed by the user\n      // so we have backpressure here\n      await writer.put(block);\n    }\n\n    await writer.close();\n\n    if (!userBlockstore) {\n      await blockstore.close();\n    }\n  };\n\n  const out = {\n    [Symbol.asyncIterator]() {\n      if (writingPromise != null) {\n        throw new Error('Multiple iterator not supported');\n      } // don't start writing until the user starts consuming the iterator\n\n\n      writingPromise = writeAll();\n      return {\n        async next() {\n          const result = await carOutIter.next();\n\n          if (result.done) {\n            await writingPromise; // any errors will propagate from here\n          }\n\n          return result;\n        }\n\n      };\n    }\n\n  };\n  return {\n    root,\n    out\n  };\n}","map":{"version":3,"sources":["/Users/g2musicgroup/Developer/NFT-starter/filecoin_nft_starter-main/node_modules/ipfs-car/dist/esm/pack/index.js"],"names":["last","pipe","CarWriter","importer","getNormaliser","MemoryBlockStore","unixfsImporterOptionsDefault","pack","input","blockstore","userBlockstore","hasher","maxChunkSize","maxChildrenPerNode","wrapWithDirectory","rawLeaves","Array","isArray","length","Error","rootEntry","source","cid","root","writer","out","carOut","create","carOutIter","Symbol","asyncIterator","writingPromise","writeAll","block","blocks","put","close","next","result","done"],"mappings":"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","sourcesContent":["import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n"]},"metadata":{},"sourceType":"module"}